#!/usr/bin/env python3
"""
Advanced Vulnerability Management System
Comprehensive vulnerability assessment and management tool with NIST CVE integration.

Author: Ariff Mohamed
License: MIT
Version: 1.0.0
"""

import requests
import json
import sqlite3
import logging
import os
import csv
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, asdict
import argparse
import concurrent.futures
from urllib.parse import urljoin
import hashlib
import re

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

@dataclass
class Vulnerability:
    """Data class for vulnerability information"""
    cve_id: str
    cvss_score: float
    severity: str
    description: str
    published_date: datetime
    modified_date: datetime
    affected_products: List[str]
    references: List[str]
    exploit_available: bool = False
    patch_available: bool = False
    in_wild_exploitation: bool = False
    epss_score: float = 0.0
    kev_catalog: bool = False
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization"""
        data = asdict(self)
        data['published_date'] = self.published_date.isoformat() if self.published_date else None
        data['modified_date'] = self.modified_date.isoformat() if self.modified_date else None
        return data

@dataclass
class VulnerabilityAssessment:
    """Data class for vulnerability assessment results"""
    target: str
    scan_date: datetime
    vulnerabilities: List[Vulnerability]
    risk_score: float
    recommendations: List[str]
    compliance_status: Dict[str, str]

class VulnerabilityManager:
    """Main vulnerability management class"""
    
    def __init__(self, config_file: str = "vuln_config.json"):
        """Initialize the vulnerability manager"""
        self.config = self.load_config(config_file)
        self.db_file = self.config.get('database', 'vulnerabilities.db')
        self.nvd_api_key = self.config.get('nvd_api_key', os.getenv('NVD_API_KEY'))
        self.init_database()
        
    def load_config(self, config_file: str) -> Dict[str, Any]:
        """Load configuration from file"""
        default_config = {
            "database": "vulnerabilities.db",
            "nvd_api_key": os.getenv("NVD_API_KEY", ""),
            "epss_api_url": "https://api.first.org/data/v1/epss",
            "kev_catalog_url": "https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json",
            "cvss_thresholds": {
                "critical": 9.0,
                "high": 7.0,
                "medium": 4.0,
                "low": 0.1
            },
            "scanning": {
                "max_workers": 10,
                "timeout": 30,
                "rate_limit_delay": 1
            },
            "risk_scoring": {
                "cvss_weight": 0.4,
                "epss_weight": 0.3,
                "exploit_weight": 0.2,
                "kev_weight": 0.1
            }
        }
        
        if os.path.exists(config_file):
            try:
                with open(config_file, 'r') as f:
                    user_config = json.load(f)
                    default_config.update(user_config)
            except Exception as e:
                logger.warning(f"Could not load config file: {e}")
        
        return default_config
    
    def init_database(self):
        """Initialize SQLite database for vulnerability storage"""
        conn = sqlite3.connect(self.db_file)
        cursor = conn.cursor()
        
        # Create vulnerabilities table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS vulnerabilities (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                cve_id TEXT UNIQUE NOT NULL,
                cvss_score REAL,
                severity TEXT,
                description TEXT,
                published_date TIMESTAMP,
                modified_date TIMESTAMP,
                affected_products TEXT,
                references TEXT,
                exploit_available BOOLEAN DEFAULT FALSE,
                patch_available BOOLEAN DEFAULT FALSE,
                in_wild_exploitation BOOLEAN DEFAULT FALSE,
                epss_score REAL DEFAULT 0.0,
                kev_catalog BOOLEAN DEFAULT FALSE,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        # Create assessments table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS assessments (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                target TEXT NOT NULL,
                scan_date TIMESTAMP,
                vulnerabilities_found INTEGER,
                critical_count INTEGER,
                high_count INTEGER,
                medium_count INTEGER,
                low_count INTEGER,
                risk_score REAL,
                compliance_status TEXT,
                recommendations TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        # Create asset inventory table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS assets (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                asset_name TEXT UNIQUE NOT NULL,
                asset_type TEXT,
                ip_address TEXT,
                operating_system TEXT,
                software_inventory TEXT,
                last_scanned TIMESTAMP,
                vulnerability_count INTEGER DEFAULT 0,
                risk_level TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        conn.commit()
        conn.close()
        logger.info("Database initialized successfully")
    
    def fetch_cve_data(self, cve_id: str) -> Optional[Vulnerability]:
        """Fetch CVE data from NIST NVD API"""
        try:
            url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
            headers = {}
            
            if self.nvd_api_key:
                headers["apiKey"] = self.nvd_api_key
            
            params = {"cveId": cve_id}
            
            response = requests.get(url, headers=headers, params=params, timeout=30)
            response.raise_for_status()
            
            data = response.json()
            
            if data.get("totalResults", 0) == 0:
                logger.warning(f"No data found for CVE {cve_id}")
                return None
            
            cve_data = data["vulnerabilities"][0]["cve"]
            
            # Extract CVSS score and severity
            cvss_score = 0.0
            severity = "unknown"
            
            metrics = cve_data.get("metrics", {})
            if "cvssMetricV31" in metrics:
                cvss_data = metrics["cvssMetricV31"][0]["cvssData"]
                cvss_score = cvss_data["baseScore"]
                severity = cvss_data["baseSeverity"].lower()
            elif "cvssMetricV30" in metrics:
                cvss_data = metrics["cvssMetricV30"][0]["cvssData"]
                cvss_score = cvss_data["baseScore"]
                severity = cvss_data["baseSeverity"].lower()
            elif "cvssMetricV2" in metrics:
                cvss_score = metrics["cvssMetricV2"][0]["cvssData"]["baseScore"]
                # Convert CVSS v2 to severity
                if cvss_score >= 7.0:
                    severity = "high"
                elif cvss_score >= 4.0:
                    severity = "medium"
                else:
                    severity = "low"
            
            # Extract description
            descriptions = cve_data.get("descriptions", [])
            description = ""
            for desc in descriptions:
                if desc.get("lang") == "en":
                    description = desc.get("value", "")
                    break
            
            # Extract dates
            published_date = datetime.fromisoformat(cve_data["published"].replace("Z", "+00:00"))
            modified_date = datetime.fromisoformat(cve_data["lastModified"].replace("Z", "+00:00"))
            
            # Extract affected products
            affected_products = []
            configurations = cve_data.get("configurations", [])
            for config in configurations:
                for node in config.get("nodes", []):
                    for cpe_match in node.get("cpeMatch", []):
                        if cpe_match.get("vulnerable", False):
                            cpe_name = cpe_match.get("criteria", "")
                            affected_products.append(cpe_name)
            
            # Extract references
            references = []
            for ref in cve_data.get("references", []):
                references.append(ref.get("url", ""))
            
            vulnerability = Vulnerability(
                cve_id=cve_id,
                cvss_score=cvss_score,
                severity=severity,
                description=description,
                published_date=published_date,
                modified_date=modified_date,
                affected_products=affected_products,
                references=references
            )
            
            # Enrich with additional data
            self.enrich_vulnerability_data(vulnerability)
            
            return vulnerability
            
        except Exception as e:
            logger.error(f"Error fetching CVE data for {cve_id}: {e}")
            return None
    
    def enrich_vulnerability_data(self, vulnerability: Vulnerability):
        """Enrich vulnerability with EPSS score and KEV catalog data"""
        try:
            # Get EPSS score
            epss_score = self.get_epss_score(vulnerability.cve_id)
            if epss_score:
                vulnerability.epss_score = epss_score
            
            # Check if in CISA KEV catalog
            vulnerability.kev_catalog = self.check_kev_catalog(vulnerability.cve_id)
            
            # Check for exploit availability (simplified heuristic)
            vulnerability.exploit_available = self.check_exploit_availability(vulnerability)
            
            # Check for patch availability (simplified heuristic)
            vulnerability.patch_available = self.check_patch_availability(vulnerability)
            
        except Exception as e:
            logger.error(f"Error enriching vulnerability data: {e}")
    
    def get_epss_score(self, cve_id: str) -> Optional[float]:
        """Get EPSS (Exploit Prediction Scoring System) score"""
        try:
            url = f"{self.config['epss_api_url']}"
            params = {"cve": cve_id}
            
            response = requests.get(url, params=params, timeout=15)
            response.raise_for_status()
            
            data = response.json()
            
            if data.get("status") == "OK" and data.get("data"):
                epss_data = data["data"][0]
                return float(epss_data.get("epss", 0.0))
            
            return None
            
        except Exception as e:
            logger.warning(f"Could not fetch EPSS score for {cve_id}: {e}")
            return None
    
    def check_kev_catalog(self, cve_id: str) -> bool:
        """Check if CVE is in CISA's Known Exploited Vulnerabilities catalog"""
        try:
            response = requests.get(self.config['kev_catalog_url'], timeout=30)
            response.raise_for_status()
            
            kev_data = response.json()
            
            for vuln in kev_data.get("vulnerabilities", []):
                if vuln.get("cveID") == cve_id:
                    return True
            
            return False
            
        except Exception as e:
            logger.warning(f"Could not check KEV catalog for {cve_id}: {e}")
            return False
    
    def check_exploit_availability(self, vulnerability: Vulnerability) -> bool:
        """Check if exploits are available (simplified heuristic)"""
        # Simple heuristic based on references
        exploit_keywords = ["exploit", "poc", "metasploit", "exploit-db"]
        
        for ref in vulnerability.references:
            ref_lower = ref.lower()
            if any(keyword in ref_lower for keyword in exploit_keywords):
                return True
        
        # High EPSS score suggests exploit availability
        if vulnerability.epss_score > 0.7:
            return True
        
        return False
    
    def check_patch_availability(self, vulnerability: Vulnerability) -> bool:
        """Check if patches are available (simplified heuristic)"""
        # Simple heuristic based on references
        patch_keywords = ["patch", "update", "advisory", "security bulletin"]
        
        for ref in vulnerability.references:
            ref_lower = ref.lower()
            if any(keyword in ref_lower for keyword in patch_keywords):
                return True
        
        # If modified recently, likely has patch information
        days_since_modified = (datetime.now(vulnerability.modified_date.tzinfo) - vulnerability.modified_date).days
        if days_since_modified < 30:
            return True
        
        return False
    
    def calculate_risk_score(self, vulnerability: Vulnerability) -> float:
        """Calculate comprehensive risk score for vulnerability"""
        weights = self.config['risk_scoring']
        
        # Normalize CVSS score (0-10 to 0-1)
        cvss_normalized = vulnerability.cvss_score / 10.0
        
        # EPSS is already 0-1
        epss_normalized = vulnerability.epss_score
        
        # Exploit availability (binary)
        exploit_score = 1.0 if vulnerability.exploit_available else 0.0
        
        # KEV catalog (binary, high weight)
        kev_score = 1.0 if vulnerability.kev_catalog else 0.0
        
        # Calculate weighted risk score
        risk_score = (
            cvss_normalized * weights['cvss_weight'] +
            epss_normalized * weights['epss_weight'] +
            exploit_score * weights['exploit_weight'] +
            kev_score * weights['kev_weight']
        )
        
        return round(risk_score * 100, 2)  # Scale to 0-100
    
    def store_vulnerability(self, vulnerability: Vulnerability):
        """Store vulnerability in database"""
        conn = sqlite3.connect(self.db_file)
        cursor = conn.cursor()
        
        try:
            cursor.execute('''
                INSERT OR REPLACE INTO vulnerabilities 
                (cve_id, cvss_score, severity, description, published_date, modified_date,
                 affected_products, references, exploit_available, patch_available,
                 in_wild_exploitation, epss_score, kev_catalog, updated_at)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                vulnerability.cve_id,
                vulnerability.cvss_score,
                vulnerability.severity,
                vulnerability.description,
                vulnerability.published_date,
                vulnerability.modified_date,
                json.dumps(vulnerability.affected_products),
                json.dumps(vulnerability.references),
                vulnerability.exploit_available,
                vulnerability.patch_available,
                vulnerability.in_wild_exploitation,
                vulnerability.epss_score,
                vulnerability.kev_catalog,
                datetime.now()
            ))
            
            conn.commit()
            logger.info(f"Stored vulnerability: {vulnerability.cve_id}")
            
        except Exception as e:
            logger.error(f"Error storing vulnerability {vulnerability.cve_id}: {e}")
        finally:
            conn.close()
    
    def scan_cve_list(self, cve_list: List[str]) -> List[Vulnerability]:
        """Scan a list of CVEs with concurrent processing"""
        vulnerabilities = []
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=self.config['scanning']['max_workers']) as executor:
            # Submit all CVE fetch tasks
            future_to_cve = {executor.submit(self.fetch_cve_data, cve): cve for cve in cve_list}
            
            for future in concurrent.futures.as_completed(future_to_cve):
                cve_id = future_to_cve[future]
                try:
                    vulnerability = future.result()
                    if vulnerability:
                        vulnerabilities.append(vulnerability)
                        self.store_vulnerability(vulnerability)
                except Exception as e:
                    logger.error(f"Error processing {cve_id}: {e}")
        
        return vulnerabilities
    
    def get_recent_cves(self, days: int = 7) -> List[str]:
        """Fetch recent CVEs from NIST NVD"""
        try:
            url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
            headers = {}
            
            if self.nvd_api_key:
                headers["apiKey"] = self.nvd_api_key
            
            # Calculate date range
            end_date = datetime.now()
            start_date = end_date - timedelta(days=days)
            
            params = {
                "pubStartDate": start_date.strftime("%Y-%m-%dT%H:%M:%S.000"),
                "pubEndDate": end_date.strftime("%Y-%m-%dT%H:%M:%S.000"),
                "resultsPerPage": 2000
            }
            
            response = requests.get(url, headers=headers, params=params, timeout=60)
            response.raise_for_status()
            
            data = response.json()
            cve_list = []
            
            for vulnerability in data.get("vulnerabilities", []):
                cve_id = vulnerability["cve"]["id"]
                cve_list.append(cve_id)
            
            logger.info(f"Found {len(cve_list)} CVEs from the last {days} days")
            return cve_list
            
        except Exception as e:
            logger.error(f"Error fetching recent CVEs: {e}")
            return []
    
    def perform_assessment(self, target: str, cve_list: List[str] = None) -> VulnerabilityAssessment:
        """Perform comprehensive vulnerability assessment"""
        logger.info(f"Starting vulnerability assessment for: {target}")
        
        scan_date = datetime.now()
        
        # If no CVE list provided, get recent CVEs
        if not cve_list:
            cve_list = self.get_recent_cves(days=30)
        
        # Scan vulnerabilities
        vulnerabilities = self.scan_cve_list(cve_list)
        
        # Calculate overall risk score
        if vulnerabilities:
            individual_risks = [self.calculate_risk_score(vuln) for vuln in vulnerabilities]
            risk_score = sum(individual_risks) / len(individual_risks)
        else:
            risk_score = 0.0
        
        # Generate recommendations
        recommendations = self.generate_recommendations(vulnerabilities)
        
        # Check compliance status
        compliance_status = self.check_compliance_status(vulnerabilities)
        
        assessment = VulnerabilityAssessment(
            target=target,
            scan_date=scan_date,
            vulnerabilities=vulnerabilities,
            risk_score=risk_score,
            recommendations=recommendations,
            compliance_status=compliance_status
        )
        
        # Store assessment
        self.store_assessment(assessment)
        
        logger.info(f"Assessment completed. Found {len(vulnerabilities)} vulnerabilities with risk score {risk_score}")
        
        return assessment
    
    def generate_recommendations(self, vulnerabilities: List[Vulnerability]) -> List[str]:
        """Generate security recommendations based on vulnerabilities"""
        recommendations = []
        
        critical_vulns = [v for v in vulnerabilities if v.severity == "critical"]
        high_vulns = [v for v in vulnerabilities if v.severity == "high"]
        kev_vulns = [v for v in vulnerabilities if v.kev_catalog]
        exploit_vulns = [v for v in vulnerabilities if v.exploit_available]
        
        if critical_vulns:
            recommendations.append(f"ðŸš¨ CRITICAL: Immediately patch {len(critical_vulns)} critical vulnerabilities")
        
        if kev_vulns:
            recommendations.append(f"âš ï¸ HIGH PRIORITY: Address {len(kev_vulns)} vulnerabilities in CISA KEV catalog")
        
        if exploit_vulns:
            recommendations.append(f"ðŸ”¥ URGENT: {len(exploit_vulns)} vulnerabilities have known exploits")
        
        if high_vulns:
            recommendations.append(f"ðŸ“‹ Plan patching for {len(high_vulns)} high severity vulnerabilities")
        
        # Generic recommendations
        recommendations.extend([
            "ðŸ”„ Implement automated patch management",
            "ðŸ“Š Establish regular vulnerability scanning schedule",
            "ðŸ›¡ï¸ Deploy additional security controls for unpatched vulnerabilities",
            "ðŸ“ˆ Monitor threat intelligence for exploitation activity",
            "ðŸŽ¯ Prioritize patches based on EPSS scores and exploit availability"
        ])
        
        return recommendations
    
    def check_compliance_status(self, vulnerabilities: List[Vulnerability]) -> Dict[str, str]:
        """Check compliance status against various frameworks"""
        status = {}
        
        critical_count = len([v for v in vulnerabilities if v.severity == "critical"])
        high_count = len([v for v in vulnerabilities if v.severity == "high"])
        kev_count = len([v for v in vulnerabilities if v.kev_catalog])
        
        # NIST compliance (simplified)
        if critical_count == 0 and high_count <= 5:
            status["NIST"] = "Compliant"
        elif critical_count <= 2 and high_count <= 15:
            status["NIST"] = "Partially Compliant"
        else:
            status["NIST"] = "Non-Compliant"
        
        # PCI DSS (stricter requirements)
        if critical_count == 0 and high_count <= 2:
            status["PCI_DSS"] = "Compliant"
        else:
            status["PCI_DSS"] = "Non-Compliant"
        
        # CISA requirements
        if kev_count == 0:
            status["CISA_KEV"] = "Compliant"
        else:
            status["CISA_KEV"] = "Non-Compliant"
        
        return status
    
    def store_assessment(self, assessment: VulnerabilityAssessment):
        """Store assessment results in database"""
        conn = sqlite3.connect(self.db_file)
        cursor = conn.cursor()
        
        try:
            # Count vulnerabilities by severity
            vuln_counts = {"critical": 0, "high": 0, "medium": 0, "low": 0}
            for vuln in assessment.vulnerabilities:
                severity = vuln.severity.lower()
                if severity in vuln_counts:
                    vuln_counts[severity] += 1
            
            cursor.execute('''
                INSERT INTO assessments
                (target, scan_date, vulnerabilities_found, critical_count, high_count,
                 medium_count, low_count, risk_score, compliance_status, recommendations)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                assessment.target,
                assessment.scan_date,
                len(assessment.vulnerabilities),
                vuln_counts["critical"],
                vuln_counts["high"],
                vuln_counts["medium"],
                vuln_counts["low"],
                assessment.risk_score,
                json.dumps(assessment.compliance_status),
                json.dumps(assessment.recommendations)
            ))
            
            conn.commit()
            logger.info(f"Stored assessment for target: {assessment.target}")
            
        except Exception as e:
            logger.error(f"Error storing assessment: {e}")
        finally:
            conn.close()
    
    def generate_vulnerability_report(self, assessment: VulnerabilityAssessment) -> str:
        """Generate comprehensive vulnerability report"""
        
        report = f"""
# ðŸ›¡ï¸ Vulnerability Assessment Report

**Target:** {assessment.target}
**Scan Date:** {assessment.scan_date.strftime('%Y-%m-%d %H:%M:%S UTC')}
**Risk Score:** {assessment.risk_score}/100

## ðŸ“Š Executive Summary

- **Total Vulnerabilities:** {len(assessment.vulnerabilities)}
- **Overall Risk Level:** {"Critical" if assessment.risk_score >= 80 else "High" if assessment.risk_score >= 60 else "Medium" if assessment.risk_score >= 40 else "Low"}

### Severity Breakdown

| Severity | Count | Percentage |
|----------|-------|------------|
"""
        
        # Calculate severity distribution
        severity_counts = {"critical": 0, "high": 0, "medium": 0, "low": 0, "unknown": 0}
        for vuln in assessment.vulnerabilities:
            severity = vuln.severity.lower()
            if severity in severity_counts:
                severity_counts[severity] += 1
            else:
                severity_counts["unknown"] += 1
        
        total_vulns = len(assessment.vulnerabilities)
        for severity, count in severity_counts.items():
            if count > 0:
                percentage = (count / total_vulns) * 100 if total_vulns > 0 else 0
                report += f"| {severity.title()} | {count} | {percentage:.1f}% |\n"
        
        report += f"""

## ðŸ” Detailed Findings

### High Priority Vulnerabilities

"""
        
        # Add high priority vulnerabilities
        high_priority = [v for v in assessment.vulnerabilities 
                        if v.severity in ["critical", "high"] or v.kev_catalog or v.exploit_available]
        
        for vuln in sorted(high_priority, key=lambda x: x.cvss_score, reverse=True)[:10]:
            risk_score = self.calculate_risk_score(vuln)
            report += f"""
#### {vuln.cve_id} - {vuln.severity.title()} ({vuln.cvss_score}/10)

- **Risk Score:** {risk_score}/100
- **Description:** {vuln.description[:200]}...
- **EPSS Score:** {vuln.epss_score:.3f}
- **Exploit Available:** {"Yes" if vuln.exploit_available else "No"}
- **KEV Catalog:** {"Yes" if vuln.kev_catalog else "No"}
- **Patch Available:** {"Yes" if vuln.patch_available else "No"}

"""
        
        report += f"""
## âœ… Compliance Status

"""
        
        for framework, status in assessment.compliance_status.items():
            emoji = "âœ…" if status == "Compliant" else "âš ï¸" if "Partial" in status else "âŒ"
            report += f"- **{framework}:** {emoji} {status}\n"
        
        report += f"""

## ðŸ’¡ Recommendations

"""
        
        for i, recommendation in enumerate(assessment.recommendations, 1):
            report += f"{i}. {recommendation}\n"
        
        report += f"""

## ðŸ“ˆ Risk Analysis

### CVSS Score Distribution

- **9.0-10.0 (Critical):** {severity_counts['critical']} vulnerabilities
- **7.0-8.9 (High):** {severity_counts['high']} vulnerabilities  
- **4.0-6.9 (Medium):** {severity_counts['medium']} vulnerabilities
- **0.1-3.9 (Low):** {severity_counts['low']} vulnerabilities

### Exploit Intelligence

- **Vulnerabilities with Known Exploits:** {len([v for v in assessment.vulnerabilities if v.exploit_available])}
- **CISA KEV Catalog Entries:** {len([v for v in assessment.vulnerabilities if v.kev_catalog])}
- **High EPSS Score (>0.7):** {len([v for v in assessment.vulnerabilities if v.epss_score > 0.7])}

## ðŸŽ¯ Next Steps

1. **Immediate Actions** (0-24 hours):
   - Patch all critical vulnerabilities
   - Address CISA KEV catalog entries
   - Implement emergency mitigations

2. **Short-term Actions** (1-7 days):
   - Patch high severity vulnerabilities
   - Update security controls
   - Conduct threat hunting

3. **Long-term Actions** (1-4 weeks):
   - Implement automated patch management
   - Enhance vulnerability scanning frequency
   - Update incident response procedures

---

*Report generated by Advanced Vulnerability Management System*
*Author: Ariff Mohamed | MIT Cybersecurity Research*
"""
        
        return report

def main():
    """Main execution function"""
    parser = argparse.ArgumentParser(description="Advanced Vulnerability Management System")
    parser.add_argument('-t', '--target', help="Target system/application name", default="Unknown")
    parser.add_argument('-c', '--cves', nargs='+', help="Specific CVEs to assess")
    parser.add_argument('-r', '--recent', type=int, help="Days of recent CVEs to fetch", default=7)
    parser.add_argument('-o', '--output', help="Output report file")
    parser.add_argument('--json', help="Output JSON report file")
    parser.add_argument('--csv', help="Output CSV file")
    
    args = parser.parse_args()
    
    # Initialize vulnerability manager
    vm = VulnerabilityManager()
    
    if args.cves:
        # Assess specific CVEs
        logger.info(f"Assessing specific CVEs: {args.cves}")
        assessment = vm.perform_assessment(args.target, args.cves)
    else:
        # Fetch and assess recent CVEs
        logger.info(f"Assessing recent CVEs from last {args.recent} days")
        recent_cves = vm.get_recent_cves(args.recent)
        if recent_cves:
            assessment = vm.perform_assessment(args.target, recent_cves[:100])  # Limit for demo
        else:
            logger.error("No CVEs found to assess")
            return
    
    # Generate reports
    report = vm.generate_vulnerability_report(assessment)
    
    if args.output:
        with open(args.output, 'w') as f:
            f.write(report)
        logger.info(f"Report saved to {args.output}")
    else:
        print(report)
    
    if args.json:
        # Convert assessment to JSON
        assessment_dict = {
            "target": assessment.target,
            "scan_date": assessment.scan_date.isoformat(),
            "risk_score": assessment.risk_score,
            "vulnerabilities": [vuln.to_dict() for vuln in assessment.vulnerabilities],
            "recommendations": assessment.recommendations,
            "compliance_status": assessment.compliance_status
        }
        
        with open(args.json, 'w') as f:
            json.dump(assessment_dict, f, indent=2)
        logger.info(f"JSON report saved to {args.json}")
    
    if args.csv:
        # Export vulnerabilities to CSV
        with open(args.csv, 'w', newline='') as f:
            writer = csv.writer(f)
            writer.writerow(['CVE_ID', 'CVSS_Score', 'Severity', 'EPSS_Score', 'Exploit_Available', 
                           'KEV_Catalog', 'Patch_Available', 'Risk_Score', 'Description'])
            
            for vuln in assessment.vulnerabilities:
                risk_score = vm.calculate_risk_score(vuln)
                writer.writerow([
                    vuln.cve_id, vuln.cvss_score, vuln.severity, vuln.epss_score,
                    vuln.exploit_available, vuln.kev_catalog, vuln.patch_available,
                    risk_score, vuln.description[:100]
                ])
        
        logger.info(f"CSV export saved to {args.csv}")

if __name__ == "__main__":
    main()